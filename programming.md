<!-- MEDIACLOUD-TOC-START -->
Содержание
=================

* [Операционные системы](#операционные-системы)
* [Программное обеспечение компьютера](#программное-обеспечение-компьютера)
* [Компьютерные сети](#компьютерные-сети)
* [Архитектура](#архитектура)
* [Алгоритмы и структуры данных](#алгоритмы-и-структуры-данных)
* [Базы данных и информационные системы](#)
* [Анализ данных](#)
* [Программирование](#)
* [Методы оптимизации](#)
* [Защита информации](#)
* [Искусственный интеллект](#)
* [Машинное обучение](#)
* [GIT](#git)

----
<!-- MEDIACLOUD-TOC-END -->

## Операционные системы
Операционная система (ОС, Operating system, OS) — это набор программ, которые обеспечивают управление и взаимодействие систем компьютера между собой, а также позволяют пользователю работать со своим оборудованием.

ОС относятся к составу системного программного обеспечения и являются основной его частью. Операционные системы: MS DOS 7.0, Windows 10, Windows 2008 Server, OS/2, UNIX, Linux.

### Основные функции ОС:
1.управление устройствами компьютера (ресурсами), т.е. согласованная работа всех аппаратных средств ПК: стандартизованный доступ к периферийным устройствам, управление оперативной памятью и др.
2.управление процессами, т.е. выполнение программ и их взаимодействие с устройствами компьютера.
3.управление доступом к данным на энергонезависимых носителях (таких как жесткий диск, компакт-диск и т.д.), как правило, с помощью файловой системы.
4.ведение файловой структуры.
5.пользовательский интерфейс, т.е. диалог с пользователем.

### Дополнительные функции:
1.параллельное или псевдопараллельное выполнение задач (многозадачность).
2.взаимодействие между процессами: обмен данными, взаимная синхронизация.
3.защита самой системы, а также пользовательских данных и программ от злонамеренных действий пользователей или приложений.
4.разграничение прав доступа и многопользовательский режим работы (аутентификация, авторизация).

Для чего нужна операционная система: без установленной ОС невозможно произвести никаких действий на компьютере. ОС выделяет и распределяет ресурсы между запущенными программами, определяет объем оперативной памяти для оптимизированной работы всего компьютера.

Основные отличия ОС друг от друга: стоимость, поддерживаемые программы, открытость кода, уровень безопасности.

**Linux** — семейство бесплатных операционных систем с открытым исходным кодом, работающих на основе одноимённого ядра. Это значит, что на базе ядра Linux могут создаваться различные операционные системы. У линукс несколько версий, которые можно использовать. Самые популярные из них: Ubuntu, Debian и Fedora.

**Unix** появилась в 1970-х годах, она стала основой для многих современных ОС. Unix сейчас используется только в серверах, так как заточен на работу с ними. У серверов нет клавиатуры и монитора, подключения идет по сетевым соединениям, поэтому разработчики не озадачились созданием привлекательного интерфейса. Зато Unix гарантирует надёжность, производительность и масштабируемость. Unix — это фундамент для всех Linux-систем.

Отличия ОС Windows и Linux
Отметим достоинства и недостатки каждой системы, которые помогут сделать выбор.

*Безопасность:*
Так как Windows более распространенная ОС, то она чаще подвергается атакам различных вирусов и угрозам, даже при домашнем использовании рекомендуется устанавливать антивирусную программу для защиты ПК. Linux в этом плане более безопасная, найденные изъяны в системе очень быстро устраняются.

*Стоимость:*
ОС Windows платная, стоимость лицензии зависит от ее вида. Чем дороже лицензия, тем больше у нее функционала. Например, в продвинутой версии есть возможность шифрования данных. Linux абсолютная бесплатная программа, поэтому она интересна для бизнесов, у которых в штате достаточное количество компьютеров.

*Установка:*
Windows устанавливается достаточно просто, с этим может разобраться даже начинающий пользователь. Сложности могут возникнуть в случае дополнительных настроек. Для установки дистрибутивов Linux потребуется загрузить образ программы на флешку. Скачать их можно на официальном сайте. Установка ОС может проходить автоматически или в ручном режиме. Возможна загрузка Linux одновременно с другой ОС, но в этом случае потребуются определенные навыки или подробная инструкция по установке.

*Требования к оборудованию:*
Для работы последних версий Windows потребуется двухъядерный процессор и 1 Гб оперативной памяти. Требования для нормальной работы Linux ниже: достаточно одноядерного процессора и 256 Мб оперативной памяти.

*Поддерживаемое программное обеспечение:*
Популярность Windows – причина большого разнообразия программ, которые разрабатываются под нее. Особенно часто под Windows делаются компьютерные игры, поэтому она является более предпочтительной ОС для геймеров. Хотя Linux постоянно дополняет список доступных программ, иногда требуется самостоятельная доработка под нестандартные задачи. Linux популярна среди разработчиков и web-программистов, они выбирают ее за гибкость настроек, безопасность и открытый код. Windows – в первую очередь используют начинающие пользователи и частные владельцы ПК по причине большого разнообразия доступных программ и простоты использования.

*Стоит ли платить за операционную систему:*
Платная ОС разрабатывается коммерческой компанией, всем своим пользователям они предоставляют техническую поддержку и помогают в решение различных вопросов. В случае бесплатных ОС таких гарантий нет. Поддержка систем и их доработка производится сообществом энтузиастов, то есть в любой момент разработчик может прекратить поддержку своего модуля или программы. Бизнес может использовать только лицензионные платные программы или программы с бесплатной лицензией (freeware). Учитывая риски, каждая компания самостоятельно принимает решение, платить за операционную систему или нет.

*Серверные операционные системы:*
Что такое серверная операционная система? Это ОС, которая необходима для управления программами, приложениями, службами и сетевыми решениями. Чем отличается серверная операционная система от обычной: серверные ОС требуют больше объема памяти, так как обеспечивают взаимодействие с большим количеством пользователей, а также могут выполнять функции почтового, игрового сервера или другие функции IT-инфраструктуры.

Основное назначение ОС для сервера — управление приложениями, которые используют все пользователи корпоративной сети или внешние пользователи. Это, например, системы управления базами данных, программы управления сетями и анализа событий в сети, средства обмена сообщениями, Web-серверы, почтовые серверы, серверные части бизнес-приложений. Поэтому требования к производительности и надежности серверных операционных систем очень высоки.

*Какие операционные системы используются на серверах?*
Microsoft Windows Server
ОС для сервера, которая знакома многим администраторам. Она достаточно удобная в использовании, обладает широким набором функций, нет проблем с совместимостью. Из негативных моментов отметим, что Windows требует чуть больше системных ресурсов, часто подвергается атакам вирусов и является платной лицензией.

**FreeBSD**
В отличие от Microsoft является бесплатной, хорошо справляется с нагрузками и достаточно безопасна. FreeBSD имеет целостное ядро, к которому применима тонкая настройка при соответствующих знаниях. Система продолжает активно развиваться. Негативные моменты: отсутствие достаточного количества инструкций по работе с системой, для администрирования нужен специалист, хорошо разбирающийся в работе системы.

**CentOS Server**
Одна из самых популярных серверных систем. Она построена на базе Red Hat Enterprise Linux (RHEL) и является продуктом с открытым исходным кодом. Популярность системы обусловлена минимальными требованиями к ресурсам.

**CentOS** поддерживает наиболее популярные панели хостинга, имеет широкую функциональность и удобный интерфейс. Ответы на вопросы по работе с системой можно найти на различных форумах и сообществах пользователей CentOS.

**Ubuntu Server**
Широко используется для веб-разработки, служб маршрутизации, терминальных серверов. ОС понятна в управлении, показывает высокую стабильность в работе, имеет регулярные обновления, хороший уровень безопасности. Из недостатком стоит отметить ограниченное количество программ, написанных для данной ОС.

**Debian Server**
Один из старейших дистрибутивов Linux. Используется бесплатно по лицензии GNU GPL. Система обладает гибкостью, высоким уровнем безопасности, требует минимальное количество ресурсов. В сети можно найти огромное количество документации от комьюнити разработчиков. Минусом системы является редкое обновление и не самый дружественный интерфейс.

**Fedora Server**
Серверная операционная система создана для хранения и обработки данных, удобного управления сервисами и инфраструктурой. Является бесплатной, надежной и безопасной, с невысокими системными требованиями. Обновления ОС выходят 1-2 раза в год. К недостаткам можно отнести ограниченное число программ для данной ОС, а для более тонкой настройки потребуются более профессиональные знания.

**Oracle Linux Server ОС**
Оптимизирована для работы баз данных, подходит для корпоративных задач по развертыванию масштабных инфраструктур, облачных нагрузок. Дистрибутив является бесплатным, но можно включить платную техническую поддержку. Система обладает дружелюбным интерфейсом, отличается стабильностью и надежностью, удобна в администрировании, поддерживает применения правок в реальном времени – то есть без перезагрузок и перерывов в работе системы. Новые версии системы выходят достаточно редко, что можно отнести к минусам данной ОС.

----
## Программное обеспечение компьютера
Программное обеспечение (ПО) – это совокупность программных и документальных средств для создания и эксплуатации систем обработки данных средствами вычислительной техники. В зависимости от функций, выполняемых программным обеспечением, его можно разделить на:
- системное ПО (базовое программное обеспечение);
- прикладное ПО;
- инструментальное ПО.

**Системное ПО** – программы, управляющие работой компьютера и выполняющие различные вспомогательные функции, например, управление ресурсами компьютера, создание копий информации, проверка работоспособности устройств компьютера, выдача справочной информации о компьютере и др. Они предназначены для всех категорий пользователей, используются для эффективной работы компьютера и пользователя, а также эффективного выполнения прикладных программ.

К **прикладному ПО** относятся программы, предназначенные для решения задач в различных сферах деятельности человека (бухгалтерские программы, текстовые и графические редакторы, базы данных, экспертные системы, переводчики, энциклопедии, обучающие, тестовые и игровые программы и т.д.).

К **инструментальному ПО** относятся среды программирования для создания новых программ (ЛОГО, QuickBASIC, Pascal, Delphi и т.д.)

**Драйверы** — это программы, обеспечивающие взаимодействие прикладных программ и операционной системы с внешними устройствами. Именно драйверы отвечают за обработку информации, поступающей от таких устройств, как мышь, клавиатура, принтер и сканер.

**Утилиты** — программы вспомогательного назначения, обеспечивающие дополнительный сервис (форматирование дискет, восстановление ошибочно удаленных файлов, дефрагментация файлов на диске и т. п.). Часть утилит входит в состав операционной системы, а другая часть функционирует независимо от неё, т.е. автономно). Утилиты могут распространятся как по одиночке, так и в составе больших и мощных утилитных комплексов, например, Norton Utilities.

**Архиваторы** (программы-упаковщики) позволяют за счет применения специальных методов сжатия уплотнять информацию, освобождая место на носителях информации. Программы-архиваторы позволяют создавать и такие архивы, для извлечения из которых содержащихся в них файлов не требуются какие-либо программы, так как сами архивные файлы называются самораспаковывающимися.

### Инструментальное ПО.

Комплекс средств, включающих в себя входной язык программирования, транслятор, машинный язык, библиотеки стандартных программ, средства отладки оттранслированных программ и компоновки их в единое целое, называется системой программирования. В системе программирования транслятор переводит программу, написанную на входном языке программирования, на язык машинных команд конкретной ЭВМ. В зависимости от способа перевода с входного языка (языка программирования) трансляторы подразделяются на компиляторы и интерпретаторы. В компиляции процессы трансляции и выполнения программы разделены во времени. Сначала компилируемая программа преобразуется в набор объектных модулей на машинном языке, которые затем собираются (компонуются) в единую машинную программу, готовую к выполнению и сохраняемую в виде файла на магнитном диске. Эта программа может быть выполнена многократно без повторной трансляции.

**Интерпретатор** осуществляет пошаговую трансляцию и немедленное выполнение операторов исходной программы: каждый оператор входного языка программирования транслируется в одну или несколько команд машинного языка, которые тут же выполняются без сохранения на диске. Таким образом, при интерпретации программа на машинном языке не сохраняется и поэтому при каждом запуске исходной программы на выполнение ее нужно (пошагово) транслировать заново. Главным достоинством интерпретатора по сравнению с компилятором является простота.

Входной язык программирования называется языком высокого уровня по отношению к машинному языку, называемому языком низкого уровня.

### Прикладное ПО.

Прикладные программы служат программным инструментарием решения прикладных задач и являются самым многочисленным классом программных продуктов. В данный класс входят программные продукты, выполняющие обработку информации различных предметных областей. Конечные пользователи таких программ – потребители информации, деятельность которых во многих случаях далека от компьютерной области. Прикладное ПО подразделяется на программы общего назначения и пакеты прикладных программ.

Программы общего назначения объединяют программы, используемые большинством пользователей и не требующие для освоения специфических знаний из других, не связанных с информатикой наук.

**Пакеты прикладных программ** – это системы программ, которые по сфере применения делятся на проблемно – ориентированные, пакеты общего назначения и интегрированные пакеты. Современные интегрированные пакеты содержат до пяти функциональных компонентов: тестовый и табличный процессор, СУБД, графический редактор, телекоммуникационные средства.

Существуют сотни текстовых редакторов, различных как по функциональным возможностям, так и по сложности освоения работы с ними. По назначению выделяют:

Редакторы документов ориентированы на работу с текстами, имеющими структуру документа, т. е. состоящими из разделов, страниц, полей, абзацев и т. д. (MS Word).

Издательские системы позволяют создавать сложные документы (рекламные буклеты, газеты, журналы, книги) высокого качества. В них процесс верстки автоматизирован, т. е. встроены специальные средства для размещения текста по страницам со вставкой рисунков, фотографий (PageMaker, QuarkXPress).

Специализированные редакторы созданы для пользователей, работающих с документами, в которых встречаются емкие формулы (например, математические или химические) и специальные символы (например, нотные знаки (ChiWriter).

Таблицы, обрабатываемые табличным процессором, называются электронными таблицами. Визуально электронные таблицы отображаются в виде прямоугольных таблиц, состоящих из строк и столбцов, пересечение которых образует ячейки. Каждая ячейка имеет свой адрес, состоящий из двух координат — имени столбца и номера строки, на пересечении которых она располагается. В ячейках могут содержаться числа, текст или формулы, задающие зависимость значения в одной ячейке от данных, находящихся в других ячейках. Табличные процессоры обычно применяются тогда, когда ведется работа с относительно сложными формулами и большими объемами исходных данных(MS Excel).

Обработкой баз данных занимаются **системы управления базами данных (СУБД)** — комплекс программ и языковых средств, предназначенных для создания и ведения базы данных, ввода, редактирования и удаления данных, организации взаимодействия баз данных с прикладными программами, обеспечения управления данными, доступа к ним, создания запросов и отчетов.

Посредством СУБД определяются физическая и логическая структуры базы данных. Физический уровень описания отражает способ физического хранения данных; логическое описание — это тот вид данных, который доступен пользователю и которым он оперирует. (MS Access).

**Графические редакторы** – программы, предназначенные для создания и обработки графических изображений. В данном классе различают растровые редакторы, векторные редакторы и программные средства для создания и обработки трехмерной графики.

Основной причиной появления интегрированных пакетов считается потребность в совместном использовании данных разных форматов. Поэтому такие пакеты разрабатывались по принципу единой (интегрированной) системы. Преимущества интегрированных пакетов проявляются в предоставлении пользователю однотипных средств доступа к данным различного вида и упрощении их переноса из одной программы пакета в другую. К недостаткам можно отнести повышенные требования к системным ресурсам (Microsoft Office).

**Веб-редакторы** – особый класс редакторов, предназначенный для создания и редактирования веб-документов. Объединяют в себе свойства текстовых и графических редакторов.

**Браузеры** – программные средства, предназначенные для просмотра электронных документов, выполненных в формате HTML. Пример: окно браузера Mozilla Firefox.

**Экспертные системы** – предназначены для анализа данных, содержащихся в базах знаний, и выдачи рекомендаций по запросу пользователя. Характерной особенностью экспертных систем является их способность к саморазвитию.

**Бухгалтерские системы** – это специализированные системы, сочетающие в себе функции текстовых и табличных редакторов, электронных таблиц и систем управления базами данных. Предназначены для автоматизации подготовки первичных бухгалтерских документов предприятия и их учета, для ведения счетов, а также для автоматической подготовки регулярных отчетов по итогам производственной, хозяйственной и финансовой деятельности.

**Программы для сканирования** предназначены для автоматического перевода печатных копий документов в электронный вид.

**Программы-переводчики** позволяют переводить информацию с одного естественного языка на другой.

**Программы-словари** — это электронные версии обычных словарей с некоторыми весьма удобными дополнительными возможностями.

----
## Компьютерные сети
Компьютерная сеть – это взаимосвязанные вычислительные устройства, которые могут обмениваться данными и совместно использовать ресурсы. Эти сетевые устройства используют систему правил, называемых коммуникационными протоколами, для передачи информации посредством физических или беспроводных технологий.




---
## GIT
### [ProGit book](https://git-scm.com/book/ru/v2)
### [Установка git](https://github.com/Hexlet/ru-instructions/blob/main/git.md)

### 1. local repo > remote repo

`mkdir hexlet-git` Создаем новый проект 

`cd hexlet-git` Переходим в созданную директорию 

`git init` Выполняем инициализацию (Initialized empty Git repository in /private/tmp/hexlet-git/.git/)

`echo 'Hello, Hexlet!' > README.md` Создаем файл README.md со строкой текста  

`echo 'Second line' >> README.md` Добавляет строку, а не заменяет

`git add README.md` Для каждого нового или измененного файла (находится в состоянии «подготовлен к коммиту» — другими словами, файл попал в индекс.)

`git commit -m 'add README.md'`  Следующий шаг — это коммит. Под этим термином понимается окончательное добавление в репозиторий, когда Git запоминает файл навсегда и следит за всеми последующими изменениями.
Во время коммита мы берем все подготовленные изменения (они могут включать любое количество файлов) и отправляем их в репозиторий как единое целое. Главное в коммите — его **атомарность**. Другими словами, он должен выполнять ровно одну задачу.

Создать репозиторий в Github.

`git remote add origin git@github.com:<ИМЯ НА ГИТХАБЕ>/hexlet-git.git` (Вам нужна ссылка для работы с репозиторием по SSH)

`git branch -M main`

`git push -u origin main`

После этой команды репозиторий, созданный на github.com, «соединяется» с локальным репозиторием hexlet-git.

`git pull --rebase` Перед началом работы нужно всегда выполнять команду, которая скачивает из внешнего репозитория новые коммиты и добавляет их в локальный репозиторий.

`git push` Залить изменения на GitHub

---
### 2. remote repo > local repo

test-repo - Создать репозиотрий в Github.

`mkdir test-repo` В GitBash 

`cd test-repo`

`git init`

`touch README.md` Создать новый файл

`git add README.md` / `git -A` / `git add --all`

`git commit -m"Add README.md"` 

`git status`

`git branch` Проверить какая ветка главная

`git remote add origin git@github.com:Talaybekovna/test-repo.git` Вы привязываете свой локальный проект к удалённому репозиторию test-repo.git на GitHub.
* git remote add — добавляет удалённый репозиторий:
* origin — имя удалённого репозитория (по умолчанию принято называть его origin).
* git@github.com:Talaybekovna/test-repo.git — SSH-ссылка на ваш репозиторий на GitHub.

`git push -u origin master` Вы загружаете код из локальной ветки master в удалённый репозиторий на GitHub: 
* git push — отправляет локальные изменения в удалённый репозиторий. 
* -u (или --set-upstream) — связывает локальную ветку с удалённой, чтобы в будущем можно было просто писать git push без указания origin master.
* origin — имя удалённого репозитория (который мы добавили в предыдущей команде).
* master — имя локальной ветки, которую отправляем.

---
`ls -la .git` Вся история о репозитории.

`ls -la` Список всех файлов репозитория.

* ! команда, которую нужно обязательно запускать перед каждым коммитом:

`git diff` Показывает изменения только для тех модифицированных файлов, которые еще не были добавлены в индекс. Подразумевается, что добавленные в индекс файлы смотреть не нужно, ведь мы их уже подготовили к коммиту.

`git diff --staged` Выведет все изменения, сделанные в рабочей директории, которые были добавлены в индекс.

`cat README.md` Содержимое файла.

`git show 5120bec` Выводится диф между этим коммитом и предыдущим. 5120bec - первые 7 символов хеша коммита (=5120bea3e5528c29f8d1da43731cbe895892eb6d)

`git blame INFO.md` Выводит файл и рядом с каждой строчкой показывает того, кто ее менял и в каком коммите.

`git grep Hexlet` Найдет слово Hexlet во всех файлах.

`git grep Hexlet $(git rev-list --all)` Возвращает список хешей коммитов `rev-list` 

---
### Просмотр истории коммитов:

`git log` Показывает список всех выполненных коммитов, отсортированных по дате добавления. Сверху мы видим самые последние коммиты.

`git log -p` или `git log --patch` Выводит диф для каждого коммита.

`git log --stat` Печатает под каждым из коммитов список и количество изменённых файлов, а также сколько строк в каждом из файлов было добавлено и удалено. В конце можно увидеть суммарную таблицу изменений.

**Формат вывода:**

`git log -- path/to/file` Ограничивает вывод только теми коммитами, в которых были изменения этих файлов.

`git log --since=2.weeks` / `git log --since="2008-10-01"` Покажет список коммитов, сделанных за последние две недели / c 01.10.2008.

`git log --pretty=oneline` == ca82a6dff817ec66f44342007202690a93763949 Change version number == Bыводит каждый коммит в одну строку (short, full, fuller)

`git log --pretty=format:"%h - %an, %ar : %s"` == ca82a6d - Scott Chacon, 6 years ago : Change version number

`--no-merges` Исключает из вывода все коммиты слияния (merge commits). Показываются только обычные (неслияющие) коммиты.


### Полезные опции для `git log --pretty=format`:
![Log Format](assets/images/log%20format1.png)

### Наиболее распространённые опции для команды `git log`:
![Log](assets/images/log%201.png)

###  Опции для ограничения вывода команды `git log`:
![Log Options](assets/images/log%202.png)

---
`rm NEW.md` Удаляет файл.

`git restore NEW.md` Восстанавливает удаленный или измененный файл.

`git rm NEW.md` == rm + git add

---
### Обнаружение ошибок:

**1. Аннотирование файла помогает, если вы знаете, где находится проблема и можете начать исследование с этого места:**

`git blame -L 69,82 Makefile` Определяет какой коммит и коммиттер отвечал за строки в Makefile и использует параметр -L для ограничения вывода аннотации строками с 69 по 82 из этого файла (когда каждая строка метода была изменена последний раз и кем.)

**2. Если вы не знаете, что сломано, а с тех пор как код работал, были сделаны десятки или сотни коммитов:**

1. `git bisect start` для запуска процесса поиска
2. `git bisect bad` сообщить Git, что текущий коммит сломан
3. `git bisect good v1.0` указать, когда было последнее известное рабочее состояние
4. `git bisect good` / `git bisect bad`  если в данном коммите проблема не проявляется / проявляется
5. `git bisect reset`  чтобы вернуть HEAD туда, где он был до начала поиска

1. `git bisect start HEAD v1.0`   первым аргументом известный плохой коммит, а вторым известный хороший коммит
2. `git bisect run test-error.sh` приведёт к автоматическому выполнению test-error.sh на каждый выгруженный коммит до тех пор, пока Git не найдёт первый сломанный коммит

---
### Поиск (места вызова/определения функции или получения истории изменения метода) по коду и коммитам 

`git grep` **Это команда для поиска текста в файлах, которые отслеживаются Git'ом**

`git grep -n gmtime_r` / `git grep --line-number gmtime_r`  чтобы распечатать номера строк, в которых Git нашёл совпадения gmtime_r

`git grep -c gmtime_r` / `git grep --count gmtime_r`  покажет только те файлы, в которых обнаружены совпадения, вместе с количеством этих совпадений в каждом файле

`git grep -p gmtime_r *.c`  если вас интересует контекст строки поиска, можно показать метод или функцию, в котором присутствует совпадение
* `-p` флаг показывает контекст метода, функции или класса, **в котором находится найденное совпадение** (Git выведет имя этой функции перед строкой результата.)
* `*.c` ограничивает поиск **только C-файлами** (файлы с расширением `.c`). Если исключить этот компонент, поиск осуществляется по всем текстовым файлам, проиндексированным в репозитории.

`git grep --break --heading -n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0`
* `--break`  Этот флаг добавляет **пустую строку** между результатами, которые найдены в **разных файлах**, чтобы их было проще читать.
* `--heading`  Выводит имя файла **один раз** перед всеми совпадениями в нём, вместо повторения имени файла для каждой строки.
* `-n`  Добавляет **номер строки** для каждой строки, где найдено совпадение.
* `-e '#define'` Флаг `-e` указывает паттерн для поиска. В данном случае команда ищет текст `#define`.
* `--and` означает, что обе части запроса должны быть выполнены.
* `\( -e LINK -e BUF_MAX \)` ищет строки, содержащие: `LINK` **или** `BUF_MAX`.
* `v1.8.0`  Указывает на поиск в указанной версии или теге репозитория. Здесь команда ищет в состоянии кода на момент тега `v1.8.0`.

`git log -S ZLIB_BUF_MAX --oneline`  покажет только те коммиты, в которых была добавлена или удалена эта строка.

`git log -L :git_deflate_bound:zlib.c` / `git log -L '/unsigned long git_deflate_bound/',/^}/:zlib.c` покажет все изменения, произошедшие с функцией git_deflate_bound в файле zlib.c


---
### [Соглашение о коммитах:](https://www.conventionalcommits.org/ru/v1.0.0/#%D0%B7%D0%B0%D1%87%D0%B5%D0%BC-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%88%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%B0%D1%85)

**A. Коммит содержит следующие структурные элементы для передачи намерений пользователям вашей библиотеки:**

1. **fix**: коммит типа fix исправляет баг в вашем коде (соответствует PATCH в Cемантическом Версионировании).
2. **feat**: коммит типа feat добавляет новую функцию в ваш код (соответствует MINOR в Cемантическом Версионировании).
3. **BREAKING CHANGE**: коммит, который имеет сноску BREAKING CHANGE или коммит, заканчивающийся восклицательным знаком (!) после типа или контекста, вводящий изменение(я), нарушающие обратную совместимость (соответствует MAJOR в Cемантическом Версионировании). BREAKING CHANGE может быть частью коммита любого типа.

----
**B. Учитывая номер версии МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ, следует увеличивать:**

1. МАЖОРНУЮ версию, когда сделаны обратно несовместимые изменения API.
2. МИНОРНУЮ версию, когда вы добавляете новую функциональность, не нарушая обратной совместимости.
3. ПАТЧ-версию, когда вы делаете обратно совместимые исправления.
4. Дополнительные обозначения для предрелизных и билд-метаданных возможны как дополнения к МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ формату.

***
**C. Структура коммита:**

`<тип>[необязательный контекст]: <описание>`

`[необязательное тело]`

`[необязательная(ые) сноска(и)]`

----
**D. Зачем использовать «Соглашение о коммитах»**
1. Автоматическое создание списков изменения.
2. Автоматическое определение семантического повышения версии (на основе типов совершённых коммитов).
3. Информирование товарищей по команде, общественности и других заинтересованных сторон о характере изменений.
4. Запуск процессов сборки и публикации.
5. Упрощать людям участие в ваших проектах, позволив им изучить более структурированную историю коммитов.

---
### У Git есть три основных состояния, в которых могут находиться ваши файлы: изменён (modified), индексирован (staged) и зафиксирован (committed):

1. К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.
2. Индексированный — это изменённый файл в его текущей версии, отмеченный для включения в следующий коммит.
3. Зафиксированный значит, что файл уже сохранён в вашей локальной базе.

---
### Статус репозитория:

Внутри директории проекта мы видим файлы проекта с одной стороны и директорию .git с другой.

Репозиторием является именно директория .git. Она хранит всю информацию о том, какие были изменения, а также сами изменения.

А вот все, что находится снаружи, это так называемая рабочая директория (working directory). Эти файлы извлекаются из .git в момент клонирования.

Каждый раз, когда мы производим изменения в рабочей директории, Git сравнивает измененные файлы с файлами внутри .git, то есть их состоянием на момент последнего коммита. Если есть изменения относительно последней зафиксированной версии, то Git сообщает нам об этом в выводе команды git status.

### P



---

---
регистрация = заказ столика в ресторане

идентификация (ввод логина) = пришёл, подходишь к администратору ресторана, говоришь я здесь заказывал столик

аутентификация (ввод пароля) = администратор говорит — докажи что ты это ты) Ты показываешь права или паспорт

авторизация = администратор смотрит в список гостей и говорит — ваш вон тот столик у туалета








### Git Cheatsheet
![Git Cheatsheet](/assets/images/git%20config%201.png)
![Git Cheatsheet](/assets/images/git%20config%202.png)
![Git Cheatsheet](/assets/images/git%20config%203.png)
![Git Cheatsheet](/assets/images/git%20config%204.png)
##
##
##
##